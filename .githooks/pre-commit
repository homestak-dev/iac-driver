#!/bin/bash
# Auto-encrypt modified plaintext files, block plaintext commits

set -e

SECRETS_DIR="secrets"
cd "$(git rev-parse --show-toplevel)"

# Skip if secrets directory doesn't exist
[ -d "$SECRETS_DIR" ] || exit 0

# Find plaintext files that have been modified and encrypt them
for plainfile in $(find "$SECRETS_DIR" -type f \( -name "*.tfvars" -o -name "*.yaml" -o -name "*.json" \) ! -name "*.enc.*" ! -name "*.enc" 2>/dev/null); do
    encfile="${plainfile}.enc"

    # If plaintext is newer than encrypted (or encrypted doesn't exist), re-encrypt
    if [ ! -f "$encfile" ] || [ "$plainfile" -nt "$encfile" ]; then
        echo "Encrypting: $plainfile -> $encfile"
        sops -e "$plainfile" > "$encfile"
        git add "$encfile"
    fi
done

# Block any plaintext secrets from being committed
PLAINTEXT_STAGED=$(git diff --cached --name-only | grep -E "^${SECRETS_DIR}/.*\.(tfvars|yaml|json)$" | grep -v "\.enc" || true)
if [ -n "$PLAINTEXT_STAGED" ]; then
    echo "ERROR: Plaintext secrets staged for commit:"
    echo "$PLAINTEXT_STAGED"
    echo ""
    echo "These files should be gitignored. Run: git reset HEAD <file>"
    exit 1
fi

# Verify staged .enc files are actually encrypted
# Check for "sops" key in both YAML (^sops:) and JSON ("sops":) formats
for encfile in $(git diff --cached --name-only | grep "\.enc$" || true); do
    if [ -f "$encfile" ] && ! grep -qE '(^sops:|"sops":)' "$encfile" 2>/dev/null; then
        echo "ERROR: $encfile doesn't appear to be SOPS-encrypted"
        exit 1
    fi
done
